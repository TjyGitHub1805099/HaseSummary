#import xx 与 from xx import yy 区别：
#使用import xx 可以修改模块对象的属性（无论属性是不是可变类型）
#使用from xx import yy 只能修改模块对象的属性是可变类型的（不可变类型不能修改,会发生属性错误）

#快捷键：
#Ctrl+/,注释语句
#Ctrl+Alt+O,可清除冗余的语句，例如未使用的import（灰色显示）

#tkinter的使用：
#1、https://blog.csdn.net/mingshao104/article/details/79591965
#2、https://blog.csdn.net/sinat_41104353/article/details/79313424
#3、https://www.cnblogs.com/xiehy/p/10826495.html
#4、https://www.jb51.net/article/119817.htm 弹窗 、子窗口
#5、https://www.cnblogs.com/yibeimingyue/p/9362511.html 菜单


import tkinter as tk
import datetime
import socket
from tkinter import messagebox          #弹窗库导入消息盒子模块
from tkinter import filedialog
from tkinter import scrolledtext        # 导入滚动文本框的模块


# 弹窗类
class MyWindow_Slave(tk.Toplevel):
  def __init__(self):#初始化
    super().__init__()
    #1、弹窗显示在主窗顶层
    self.attributes("-topmost", 1)
    self.wm_attributes("-topmost", 1)
    #2、弹窗名字
    self.title('Serial Options')
    #3、弹窗大小及位置
    # sw = self.winfo_screenwidth()# 获取屏幕长宽
    # sh = self.winfo_screenheight()# 获取屏幕宽宽
    # ww = 200# 所需串口长度
    # wh = 200# 所需串口宽度
    # self.geometry("%dx%d+%d+%d" % (ww, wh, ((sw - ww) / 2), ((sh - wh) / 2)))#新窗口大小(居中)
    #4、弹窗内容设定
    self.setup_UI()

  def setup_UI(self):
   # 第1行（两列）
    row1 = tk.Frame(self)
    row1.pack(fill="x")#
    tk.Label(row1, text='Port:', width=8).pack(side=tk.LEFT)
    self.Port = tk.StringVar()
    tk.Entry(row1, textvariable=self.Port, width=10).pack(side=tk.LEFT)
    # 第2行
    row2 = tk.Frame(self)
    row2.pack(fill="x", ipadx=1, ipady=1)
    tk.Label(row2, text='Baud rete:', width=8).pack(side=tk.LEFT)
    self.BaudRate = tk.IntVar()
    tk.Entry(row2, textvariable=self.BaudRate, width=10).pack(side=tk.LEFT)
    # 第3行
    row3 = tk.Frame(self)
    row3.pack(fill="x", ipadx=1, ipady=1)
    tk.Label(row3, text='Data bits:', width=8).pack(side=tk.LEFT)
    self.DataBits = tk.IntVar()
    tk.Entry(row3, textvariable=self.DataBits, width=10).pack(side=tk.LEFT)
    # 第4行
    row4 = tk.Frame(self)
    row4.pack(fill="x", ipadx=1, ipady=1)
    tk.Label(row4, text='Parity:', width=8).pack(side=tk.LEFT)
    self.Parity = tk.StringVar()
    tk.Entry(row4, textvariable=self.Parity, width=10).pack(side=tk.LEFT)
    # 第5行
    row5 = tk.Frame(self)
    row5.pack(fill="x", ipadx=1, ipady=1)
    tk.Label(row5, text='Stop bits:', width=8).pack(side=tk.LEFT)
    self.StopBits = tk.IntVar()
    tk.Entry(row5, textvariable=self.StopBits, width=10).pack(side=tk.LEFT)
    # 第6行
    row6 = tk.Frame(self)
    row6.pack(fill="x")
    tk.Button(row6, text="取消", command=self.cancel).pack(side=tk.LEFT)
    tk.Button(row6, text="确定", command=self.ok).pack(side=tk.RIGHT)

   # 关闭窗口事件处理
    self.protocol("WM_DELETE_WINDOW", self.window_closing)

  def ok(self):
    self.userinfo = [self.Port.get(), self.BaudRate.get(), self.DataBits.get(), self.Parity.get(), self.StopBits.get()]  # 设置数据
    self.destroy()#销毁窗口

  def cancel(self):
    self.userinfo = None # 空！
    self.destroy()

  def window_closing(self):
    self.wm_attributes("-topmost", 0)  # 取消本窗口置顶
    if messagebox.askokcancel("Exit Setting", "Quit SessionManager Setting ?"):#确认 Quit 事件
      self.userinfo = None  # 空！
      self.destroy()
    else:#取消 Quit 事件
        self.wm_attributes("-topmost", 1)#本窗口置顶

# 主窗类
class MyWindow_Host(tk.Tk):
  def __init__(self):
    super().__init__()
    #1、主窗名字
    self.title('My Window')
    #2、主窗大小及位置
    sw = self.winfo_screenwidth()# 获取屏幕长宽
    sh = self.winfo_screenheight()# 获取屏幕宽宽
    ww = 1200# 所需串口长度
    wh = 600# 所需串口宽度
    self.geometry("%dx%d+%d+%d" % (ww, wh, ((sw - ww) / 2), ((sh - wh) / 2)))#新窗口大小(居中)
    #类的参数
    self.Port = 'COM1'#端口名字
    self.BaudRate = 9600#波特率
    self.DataBits = 8#8位数据位
    self.Parity = 'None'#无校验
    self.StopBits = 1#1个停止位
    self.SerialSet = False#用于设置功能互斥
    #主窗内容设定
    self.setup_UI()

  def setup_UI(self):
    menubar = tk.Menu(self)  # 指定tkinter菜单

    def File_New_Event():
        fname = filedialog.askopenfilename(
        filetypes=(("Text file", "*.txt*"), ("DBC file", "*.dbc*"), ("HTML files", "*.html;*.htm")))

    def File_Open_Event():
        FilePath = filedialog.askopenfilename(filetypes=(("DBC file", "*.dbc*"), ("Text file", "*.txt*"), ("HTML files", "*.html;*.htm")))  # 打开提示框，选则文件，输出文件绝对路径
        fp = open(FilePath, mode='r+')#打开文件 读写方式
        fp.truncate()#清空文件
        f_note = fp.read()#读文件
        f_note +='/* Warning : Please don\'t modify this file,this is generated by tools */' + '\r' \
                 '/***********************************************************************' + '\r' \
                 '*File Name   :123.dbc' + '\r' \
                 '*Version     :' + 'V1.0' + '\r' \
                 '*Author      :' + socket.gethostname() + '\r' \
                 '*Time        :' + datetime.datetime.now().strftime('%F %T') + '\r' \
                 '*Description :' + '\r' \
                 '*/'
        fp.write(f_note)#写入文件
        fp.close()#关闭文件
        pass

    def File_Save_Event():
        FilePath = filedialog.askopenfilename(filetypes=(
        ("DBC file", "*.bin*"), ("Text file", "*.txt*"), ("HTML files", "*.html;*.htm")))  # 打开提示框，选则文件，输出文件绝对路径
        fp = open(FilePath, mode='r+')  # 打开文件 读写方式
        f_note = fp.read()  # 读文件
        fp.close()  # 关闭文件
        pass

    def File_SaveAs_Event():
        pass

    fmenu1 = tk.Menu(self)
    fmenu1.add_command(label='新建', command=None)
    fmenu1.add_command(label='打开', command=File_Open_Event)
    fmenu1.add_command(label='保存', command=None)
    fmenu1.add_command(label='另存为', command=None)

    fmenu2 = tk.Menu(self)
    for item in ['复制', '粘贴', '剪切']:
        fmenu2.add_command(label=item)

    fmenu3 = tk.Menu(self)
    for item in ['默认视图', '新式视图']:
        fmenu3.add_command(label=item)

    fmenu4 = tk.Menu(self)
    for item in ["版权信息", "其他说明"]:
        fmenu4.add_command(label=item)

    fmenu5 = tk.Menu(self)
    fmenu5.add_command(label='SessionManager',command=self.SessionManager)

    menubar.add_cascade(label="文件", menu=fmenu1)  # 菜单项：文件
    menubar.add_cascade(label="编辑", menu=fmenu2)  # 菜单项：编辑
    menubar.add_cascade(label="视图", menu=fmenu3)  # 菜单项：视图
    menubar.add_cascade(label="关于", menu=fmenu4)  # 菜单项：关于
    menubar.add_cascade(label="设置", menu=fmenu5)  # 菜单项：设置
    # 最后可以用窗口的 menu 属性指定我们使用哪一个作为它的顶层菜单
    self.config(menu=menubar)

    #关闭窗口事件处理
    self.protocol("WM_DELETE_WINDOW", self.window_closing)

  # 设置参数
  def SessionManager(self):
      if self.SerialSet is False:
        self.SerialSet = True#自定义，防止再次点击设置
        # 接收弹窗的数据
        res = self.ask_userinfo()
        #print(res)
        if res is None: return
        # 更改参数
        self.Port, self.BaudRate, self.DataBits, self.Parity, self.StopBits = res
        # 更新界面里面数据
        print(self.Port)
        print(self.BaudRate)
        print(self.DataBits)
        print(self.Parity)
        print(self.StopBits)

  # 弹窗
  def ask_userinfo(self):
    inputDialog = MyWindow_Slave()
    self.wait_window(inputDialog) # 这一句很重要！！！
    # 使能主窗口再设置
    self.SerialSet = False
    return inputDialog.userinfo

  def window_closing(self):
    if messagebox.askokcancel("关闭", "退出主窗口?"):#确认 Quit 事件
      self.destroy()

if __name__ == '__main__':
  app = MyWindow_Host()
  app.mainloop()