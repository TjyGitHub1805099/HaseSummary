/*!
   @defgroup mpu Memory Protection Unit (MPU)
   @brief The S32 SDK provides Peripheral Driver for the Memory Protection Unit (MPU) module of S32 SDK devices.
   @details The memory protection unit (MPU) provides hardware access control for all memory references generated in the device.@n

   ## Hardware background ##

    The MPU concurrently monitors all system bus transactions and evaluates their
    appropriateness using pre-programmed region descriptors that define memory spaces and
    their access rights. Memory references that have sufficient access control rights are
    allowed to complete, while references that are not mapped to any region descriptor or
    have insufficient rights are terminated with a protection error response.

    The MPU implements a two-dimensional hardware array of memory region descriptors
    and the crossbar slave ports to continuously monitor the legality of every memory
    reference generated by each bus master in the system.

    The feature set includes:
    - 8(16 for S32K148) program-visible 128-bit region descriptors, accessible by four 32-bit words each
      - Each region descriptor defines a modulo-32 byte space, aligned anywhere in
        memory
        - Region sizes can vary from 32 bytes to 4 Gbytes
      - Two access control permissions defined in a single descriptor word
        - Masters 0–3: read, write, and execute attributes for supervisor and user
          accesses
        - Masters 4–7: read and write attributes
      - Hardware-assisted maintenance of the descriptor valid bit minimizes coherency
        issues
      - Alternate programming model view of the access control permissions word
      - Priority given to granting permission over denying access for overlapping region
        descriptors
    - Detects access protection errors if a memory reference does not hit in any memory
      region, or if the reference is illegal in all hit memory regions. If an access error
      occurs, the reference is terminated with an error response, and the MPU inhibits the
      bus cycle being sent to the targeted slave device.
    - Error registers, per slave port, capture the last faulting address, attributes, and other
      information
    - Global MPU enable/disable control bit
 */

/*!
@defgroup mpu_drv MPU Driver
@ingroup mpu

# Pre-Initialization information of MPU module

1. Before using the MPU driver the protocol clock of the module must be configured by the application using PCC module.
2. Bus fault or Hard fault exception must be configured to handle MPU access violation.


## Initialization and Deinitialize{#MPUInit}

To initialize the MPU module, call the MPU_DRV_Init() function and provide the user configuration data structure.
This function sets the configuration of the MPU module automatically and enables the MPU module. \n
Note that the configuration for region 0:
 - The access right for <b>CORE, DMA,..</b> can be <b>changed</b> except <b>DEBUGGER</b> master.
 - The <b>start address</b>, <b>end address</b>, <b>process identifier</b> and <b>process identifier mask</b> are <b>ignored</b>.

This is example code to configure the MPU driver:
1. Define MPU instance
~~~~~{.c}
    /* MPU 0 */
    #define INST_MPU 0U
~~~~~

2. Configuration \n
User configuration
~~~~~{.c}
    /* Region count */
    #define REGION_CNT (1U)

    /* Master access configuration
     * FEATURE_MPU_MASTER_COUNT macro has been already defined (number of masters supported by hardware)
     */
    mpu_master_access_right_t masterAccRight[FEATURE_MPU_MASTER_COUNT] =
    {
       /* CORE */
        {
            .masterNum   = FEATURE_MPU_MASTER_CORE,        /* Master number */
            .accessRight = MPU_SUPERVISOR_RWX_USER_RWX,    /* Access right */
            .processIdentifierEnable = false,              /* Process identifier enable */
        },
        /* The rest masters should be defined here */
        ...
    }
    /* User configuration */
    mpu_user_config_t userConfig[REGION_CNT] =
    {
        /* Region 0 */
        {
            .startAddr          = 0x00000000U,       /* Memory region start address */
            .endAddr            = 0xFFFFFFFFU,       /* Memory region end address */
            .masterAccRight     = masterAccRight,    /* Master access right */
            .processIdEnable    = false,             /* Process identifier enable */
            .processIdentifier  = 0x00U,             /* Process identifier */
            .processIdMask      = 0x00U              /* Process identifier mask */
        }
    }
~~~~~
or get default configuration
~~~~~{.c}
    /* Defines master access right structure */
    mpu_master_access_right_t masterAccRight[FEATURE_MPU_MASTER_COUNT];

    /* Gets default region configuration
     * Access right of all masters are allowed
     */
    mpu_user_config_t regionConfig0 = MPU_DRV_GetDefaultRegionConfig(masterAccRight);
    mpu_user_config_t userConfig[REGION_CNT] =
    {
        regionConfig0
    };
~~~~~

3. Initializes
~~~~~{.c}
    /* Initializes the MPU instance */
    MPU_DRV_Init(INST_MPU, REGION_CNT, userConfig);
~~~~~

4. De-initializes
~~~~~{.c}
    /* De-initializes the MPU instance */
    MPU_DRV_Deinit(INST_MPU);
~~~~~

## Basic Control Operations {#MPUBasicOp}

After MPU initialization: @n
- The MPU_DRV_SetRegionConfig() can be used to configure the region descriptor.
- The MPU_DRV_SetRegionAddr() can be used to configure the region start and end address.
- The MPU_DRV_SetMasterAccessRights() can be used to configure access permission of master in the region.
- The MPU_DRV_GetDetailErrorAccessInfo() API is provided to get the error status of a special slave port. When an error happens in this port, the MPU_DRV_GetDetailErrorAccessInfo() API is provided to get the detailed error information.
- The MPU_DRV_EnableRegion() can be used to enable or disable region descriptor.

 */
