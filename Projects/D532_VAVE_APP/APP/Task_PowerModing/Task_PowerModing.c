/*!Warning!:Please don't modify this file,this is generated by tools!*/
/********************************************************************
File name: Task_PowerModing.c
Author: Stephen Du
Version: V1.0
Timestamp: 2018-09-06 16:36:07
Description:
Others:
Function List:
1. ....
History: /
1. Date:
Author:
Modification:
2. ...
********************************************************************/
#include "System_Task.h"
#include "System_Signal.h"
#include "Task_PowerModing_Cfg.h"
#if (STD_ON == TASK_POWERMODING_DEBUG_TRACE)
#include "trace.h"
#endif
/*********** START: INCLUDE FILES ************/
#include "dea.h"
#include "Eeprom.h"
#include "Standby.h"
#include "PowerSupply.h"
#include "BattVoltage.h"
#include "HardwareVersion.h"

#include "pm_Cfg.h"
#include "pmStateMachine_If.h"
#include "pmStateMachine.h"

#include "Spi_Ipc_gw_api.h"
#include "Task_M_IpcApp_Cfg.h" 

#include "pin_wrapper_if.h"

#include "SysWakeUp.h"

#include "BinSig_Acc_Cfg.h"

#include "MemMap.h"
#include "BoardDefines.h"

#include "SecondPanel.h"
#include"CanApp.h"


extern PMSignalStatusType PMSignalStatus;
extern PMManagerType PMManager;
extern uint8 gVariantCtrlVersion;
extern BACKRAM_START_SEC_VAR_UNSPECIFIED uint32 g_BootLoaderJumpCmd;

extern uint8 g_PowerModingTrace;
#if ( STD_ON == PM_U1000_SOLUTION )
	extern void PM_ALL_OFF_WakeUpComeCheck();
#endif
/************ END: INCLUDE FILES *************/
void Task_PowerModing(void * pvParameters)
{
	boolean l_returnValue = E_NOT_OK;
	SystemTaskMsgInfoType l_msgInfo = {0XFFFF, 0U, NULL};
#if (STD_ON == TASK_POWERMODING_STACK_MONITOR)
	uint16 l_stackSize = 0U;
#endif
	/*===============================================================================*/
	/*=============================== START: USER CODE ==============================*/
	/*===============================================================================*/
	/***************************** START: VARIABLE DEFINE ****************************/
	/*Warning: Change the following array size according to your real length.*/
	uint8 l_msgDataBuf[4] = {0U, 0U, 0U, 0U};
	uint32 l_event = 0Xffff;
	uint8 l_Acc_Status = 0;
	uint8 l_Tcu_Acc_Status = 0;
	uint8 l_Ign_Status = 0;
	boolean l_OneSecCntFlag = FALSE;
	uint8 l_OneSecCnt = 0;
	uint8 l_ScrKeyVal = 0;
	uint8 l_VolDOwnKeyVal = 0;
	uint32 l_updateFlag = USB_UPDATE_ENABLE_MFG_FLAG;
	uint16 sysVol = 0;
	uint8 l_canWakeUpFlag = STD_OFF;
	uint32	status = 0;
	uint8 l_value = 0;
	
	/****************************** END: VARIABLE DEFINE *****************************/
	
	/********************* START: SOMETHING ONLY NEED EXEC ONCE **********************/
	l_msgInfo.parBufPtr = &l_msgDataBuf[0];
	//PMManager.circuitVersion = getCircuitVerion();
	//PMManager.variantCtrl = getVariantCtrlVerion();
	PMManager.variantCtrl = gVariantCtrlVersion;
	/********************** END: SOMETHING ONLY NEED EXEC ONCE ***********************/
	
	/**************************** START: SIGNAL SUBSCRIBE ****************************/
	/*
	System_Signal_Subscribe(SYSTEM_SIG_ID_XXX, SYSTEM_TASK_ID_POWERMODING);
	System_Signal_SubSpecValue(SYSTEM_SIG_ID_XXX, SYSTEM_TASK_ID_POWERMODING, X);
	*/
	#if 1
	System_Signal_Subscribe(SYSTEM_SIG_ID_ACC, SYSTEM_TASK_ID_POWERMODING);
	//System_Signal_Subscribe(SYSTEM_SIG_ID_TCU_ACC, SYSTEM_TASK_ID_POWERMODING);
	System_Signal_Subscribe(SYSTEM_SIG_ID_IGN, SYSTEM_TASK_ID_POWERMODING);
	System_Signal_Subscribe(SYSTEM_SIG_ID_REVERSE, SYSTEM_TASK_ID_POWERMODING);
	System_Signal_Subscribe(SYSTEM_SIG_ID_REMOTE_START, SYSTEM_TASK_ID_POWERMODING);
	System_Signal_Subscribe(SYSTEM_SIG_ID_CAN_AWAKE, SYSTEM_TASK_ID_POWERMODING);
	System_Signal_Subscribe(SYSTEM_SIG_ID_CAN_SLEEP, SYSTEM_TASK_ID_POWERMODING);
	System_Signal_Subscribe(SYSTEM_SIG_ID_CUSTOMER_HANDOVER, SYSTEM_TASK_ID_POWERMODING);
	System_Signal_Subscribe(SYSTEM_SIG_ID_5S, SYSTEM_TASK_ID_POWERMODING);
	System_Signal_Subscribe(SYSTEM_SIG_ID_BATTVOLT_STATUS, SYSTEM_TASK_ID_POWERMODING);
	System_Signal_Subscribe(SYSTEM_SIG_ID_UPDATE, SYSTEM_TASK_ID_POWERMODING);
	System_Signal_Subscribe(SYSTEM_SIG_ID_10MS, SYSTEM_TASK_ID_POWERMODING);
	System_Signal_Subscribe(SYSTEM_SIG_ID_1S, SYSTEM_TASK_ID_POWERMODING);
	System_Signal_Subscribe(SYSTEM_SIG_ID_500MS, SYSTEM_TASK_ID_POWERMODING);
	System_Signal_Subscribe(SYSTEM_SIG_ID_LVI_SLEEP, SYSTEM_TASK_ID_POWERMODING);
	System_Signal_Subscribe(SYSTEM_SIG_ID_7MS, SYSTEM_TASK_ID_POWERMODING);
	System_Signal_Subscribe(SYSTEM_SIG_ID_60S, SYSTEM_TASK_ID_POWERMODING);
	//System_Signal_Subscribe(SYSTEM_SIG_ID_SWC_PRESS, SYSTEM_TASK_ID_POWERMODING);
	System_Signal_Subscribe(SYSTEM_SIG_ID_SOC_READY_TO_POWER_OFF, SYSTEM_TASK_ID_POWERMODING);//add by tjy @2019-11-27,used for power off SOC
	#endif
	/***************************** END: SIGNAL SUBSCRIBE *****************************/
	/*===============================================================================*/
	/*================================ END: USER CODE ===============================*/
	/*===============================================================================*/
	while (1)
	{
		l_returnValue = System_Task_ReceiveMessage(SYSTEM_TASK_ID_POWERMODING, &l_msgInfo, FALSE, OS_WAITFOREVER);
		if (E_OK == l_returnValue)
		{
			/*
			You can use: "l_msgInfo.msgId" to get the message id.
			You can use: "l_msgInfo.size" to get the message size.
			You can use: "l_msgInfo.parBufPtr[]" or "l_msgDataBuf[]"
			             to get the message content if the message size not equal 0.
			 */
			/*===============================================================================*/
			/*=============================== START: USER CODE ==============================*/
			/*===============================================================================*/
			/*if (SYSTEM_SIG_ID_XXX == l_msgInfo.msgId)
			{
#if (STD_ON == TASK_POWERMODING_DEBUG_TRACE)
				TracePrintf(POWERMODING_TRACE, TRACE_INFO, "[Task_PowerModing-I]:Some infomation\r\n");
#endif
			}*/


		#if 1
			l_event = PM_SIG_MAX;
			switch(l_msgInfo.msgId)
			{
				case SYSTEM_SIG_ID_10MS:
					#if ( STD_ON == PM_U1000_SOLUTION )
						PM_ALL_OFF_WakeUpComeCheck();
					#endif
					Ex_Wdg_Refresh();//external watch dog refresh,add by tjy,@2019-12-12
					#if ( STD_ON == UG8V_ERR_CHECK_EN )
						UG8V_Err_Check_Main();//used to solve under -35â„ƒ power UG8V lose efficacy,add by tjy,@2019-12-24
					#endif
					
					l_event = PM_SIG_CYCLE;
					//====================================================================================================
					if( TRUE == g_PowerModingTrace )
					{
						g_PowerModingTrace = FALSE; 		
						TracePrintf(PM_TRACE, TRACE_ERRO, "[PM-I]:Acc_status = %d\n\r",PMSignalStatus.Acc_status);
						TracePrintf(PM_TRACE, TRACE_ERRO, "[PM-I]:Ign_status = %d\n\r",PMSignalStatus.Ign_status);
						
						TracePrintf(PM_TRACE, TRACE_ERRO, "[PM-I]:RmtStart_Flag = %d\n\r",PMSignalStatus.RmtStart_Flag);					
						TracePrintf(PM_TRACE, TRACE_ERRO, "[PM-I]:ISS_ACT = %d\n\r",PMSignalStatus.ISS_ACT);
						TracePrintf(PM_TRACE, TRACE_ERRO, "[PM-I]:EngineStatus = %d\n\r",PMSignalStatus.EngineStatus);
						TracePrintf(PM_TRACE, TRACE_ERRO, "[PM-I]:DoorSwitchesState = %d\n\r",PMSignalStatus.DoorSwitchesState);
						TracePrintf(PM_TRACE, TRACE_ERRO, "[PM-I]:DAwakeupRequest = %d\n\r",PMSignalStatus.DAwakeupRequest);
						TracePrintf(PM_TRACE, TRACE_ERRO, "[PM-I]:Photo_Request = %d\n\r",PMSignalStatus.AVM_Outdoor_Photo_Request);
						
						TracePrintf(PM_TRACE, TRACE_ERRO, "[PM-I]:TouchScreenStatus = %d\n\r",PMSignalStatus.TouchScreenStatus);
						TracePrintf(PM_TRACE, TRACE_ERRO, "[PM-I]:CanSleepStatus = %d\n\r",PMSignalStatus.CanSleepStatus);
					}
					//====================================================================================================
					break;
					
				case SYSTEM_SIG_ID_7MS:
					l_event = PM_SIG_7MS;
					break;
				
				case SYSTEM_SIG_ID_LVI_SLEEP:
					#if 1
						//if 7ms open restart it
						Alarm_GetStatus(SYSTEM_SIG_ID_7MS, &status);
						if( ALARM_STATE_RUNNING == status )
							Alarm_Stop(ALARM_ID_7MS);
					#endif
					
					//used for 5ms "micro level interrupt"
					Alarm_Start(ALARM_ID_7MS);

					if(BattVolt_GetRawValue(&sysVol) != E_OK)
						sysVol = 0xFFFF;
					
					if(SYS_LVI_APPEAR == GetPinValue_LVI_DET())// Vbat < 7.8v
					{
						TracePrintf(PM_TRACE, TRACE_ERRO, "[PM-I]:LVI detected(%d),start 7ms ,run = %d\n\r",sysVol,status);
					}
					else if(SYS_HVI_APPEAR == GetPinValue_LVI_DET1() )// Vbat > 16.8v or Vbat < 7.8v
					{
						TracePrintf(PM_TRACE, TRACE_ERRO, "[PM-I]:HVI detected(%d),start 7ms ,run = %d\n\r",sysVol,status);
					}
					break;

				case SYSTEM_SIG_ID_ACC:
					if (ACC_ON == *(uint32*)(l_msgInfo.parBufPtr))
					{
						l_event = PM_SIG_ACC_ON;
						l_Acc_Status = STD_ON;
						PMSignalStatus.Acc_status = STD_ON;

						PM_EX_AMP_OnOff(STD_ON);
						ClearFlagBit(&g_sSecondPanelSendDataFlag, SecondPanel_ValidEnable);
					}
					else
					{
						l_event = PM_SIG_ACC_OFF;
						l_Acc_Status = STD_OFF;
						PMSignalStatus.Acc_status = STD_OFF;
						
						PM_EX_AMP_OnOff(STD_OFF);
						SetFlagBit(&g_sSecondPanelSendDataFlag, SecondPanel_ValidEnable);
					}
					
					if(socOnFlag == TRUE)
					{
						ipc_send_notification(DA_IPC_HW_CH,IPC_CH_DA_PWR,ACC_STATUS,&l_Acc_Status,DA_IPC_NTFY_LEN);
					}
					//ipc_gw_send_request_no_reply(IPC_CHANNEL_POWERMODING, IPC_TX_SYS_ACC_STATUS,&Status,1);
					DEA_SetAccStat((ACC_STAT_ENUM)l_Acc_Status);
					break;
					
				case SYSTEM_SIG_ID_TCU_ACC:
					if (PM_TCU_ACC_ON == *(uint32*)(l_msgInfo.parBufPtr))
					{
						l_event = PM_SIG_TCU_ACC_ON;
						l_Tcu_Acc_Status = STD_ON;
						PMSignalStatus.Tcu_Acc_status = STD_ON;
					}
					else
					{
						l_event = PM_SIG_TCU_ACC_OFF;
						l_Tcu_Acc_Status = STD_OFF;
						PMSignalStatus.Tcu_Acc_status = STD_OFF;
					}
					
					if(socOnFlag == TRUE)
					{
						ipc_send_notification(DA_IPC_HW_CH,IPC_CH_DA_PWR,TCU_ACC_STATUS,&l_Tcu_Acc_Status,DA_IPC_NTFY_LEN);
					}
					break;
					
				case SYSTEM_SIG_ID_IGN:
					if (PM_IGN_ON == *(uint32*)(l_msgInfo.parBufPtr))
					{
						l_event = PM_SIG_IGN_ON;
						l_Ign_Status = STD_ON;
						PMSignalStatus.Ign_status = STD_ON;
					}
					else
					{
						l_event = PM_SIG_IGN_OFF;
						l_Ign_Status = STD_OFF;
						PMSignalStatus.Ign_status = STD_OFF;
					}
					//VDC and HDC ON/OFF signal need send invalid value when ign status changed.requested by LiQian
					Com_SetSignal(SIG_HND_HDC_ONOFF, &l_value);
					Com_SetSignal(SIG_HND_VDC_ONOFF, &l_value);
					CanApp_setMsg_0x5e5_CheckSum(SIG_HND_VDC_ONOFF);
					
					if(socOnFlag == TRUE)
					{
						ipc_send_notification(DA_IPC_HW_CH,IPC_CH_DA_PWR,IGN_STATUS,&l_Ign_Status,DA_IPC_NTFY_LEN);
					}
					DEA_SetIgnStat((IGN_STAT_ENUM)l_Ign_Status);
					break;

				case SYSTEM_SIG_ID_REVERSE:
					if (STD_OFF == *(uint32*)(l_msgInfo.parBufPtr))
					{
						PMSignalStatus.Reverse_status = STD_ON;
					}
					else
					{
						PMSignalStatus.Reverse_status = STD_OFF;
					}
					
					if(socOnFlag == TRUE)
					{
						ipc_send_notification(DA_IPC_HW_CH,IPC_CH_DA_PWR,REVERSE_STATUS,&(PMSignalStatus.Reverse_status),DA_IPC_NTFY_LEN);
					}
					break;

				case SYSTEM_SIG_ID_CAN_AWAKE:
					if (STD_ON == *(uint32*)(l_msgInfo.parBufPtr))
					{
						l_canWakeUpFlag = STD_ON;
						PMSignalStatus.CanSleepStatus = STD_OFF;
						l_event = PM_SIG_CAN_AWAKE;

						Alarm_GetStatus(SYSTEM_SIG_ID_60S, &status);
						if(ALARM_STATE_RUNNING == status)
							Alarm_Stop(ALARM_ID_60S);
					}
					else
					{
						l_canWakeUpFlag = STD_OFF;
						PMSignalStatus.CanSleepStatus = STD_ON;
						l_event = PM_SIG_CAN_SLEEP;
					}
					break;
					
#if 0
				case SYSTEM_SIG_ID_CAN_SLEEP:
					l_event = PM_SIG_CAN_SLEEP;
					break;
				
				case SYSTEM_SIG_ID_CUSTOMER_HANDOVER:
					l_event = PM_SIG_CUSTOMER_HANDOVER;
					break;	
#endif
				
				case SYSTEM_SIG_ID_5S:
				case SYSTEM_SIG_ID_SOC_READY_TO_POWER_OFF:
					//if this time ACC ON or CAN WAKE again , restart syetem
					if((ACC_ON	== BINSIG_ACC_GET_PORT_VALUE)//ACC_ON
						||(STD_ON == l_canWakeUpFlag)) 
					{
						//set backram flag ,used for bootloader jump to app as soon as possible when wake up
						g_BootLoaderJumpCmd = JUMP_TO_APP_AT_ONCE;
						SysResetWrapper_AndStore(PM_RESET);
						//SysResetWrapper(PM_RESET);
						l_event = 0XFFFF;
					}
					else
					{
						gSystemsleeping = TRUE;//used to ,after soc power off done ,set wake up enable ,but not reset
						//SysWakeUpEnable();
						SysLviWakeUpEnable();
						SysLocationWakeUpEnable();
						l_event = PM_SIG_FIVE_SECONDS;
					}
					break;
				
				case SYSTEM_SIG_ID_1S:
					l_event = PM_SIG_ONE_SECOND;
					break;

				case SYSTEM_SIG_ID_500MS:
					//if this time ACC ON or CAN WAKE again , restart syetem
					if((ACC_ON	== BINSIG_ACC_GET_PORT_VALUE)//ACC_ON
						||(STD_ON == l_canWakeUpFlag)) 
					{
						//set backram flag ,used for bootloader jump to app as soon as possible when wake up
						g_BootLoaderJumpCmd = JUMP_TO_APP_AT_ONCE;
						
						SysResetWrapper(PM_RESET);
						l_event = 0XFFFF;
					}
					else
					{
						gSystemsleeping = TRUE;//used to ,after soc power off done ,set wake up enable ,but not reset
						//SysWakeUpEnable();
						SysLviWakeUpEnable();
						SysLocationWakeUpEnable();
						l_event = PM_SIG_500MS;
					}
					break;

				case SYSTEM_SIG_ID_BATTVOLT_STATUS:
					if(BattVolt_GetRawValue(&sysVol) != E_OK)
						sysVol = 0xFFFF;
					if(BATTVOLT_STATE_NORMAL == *(uint32*)(l_msgInfo.parBufPtr))
					{
						l_event = PM_SIG_VOLT_NORMAL;
					}
					else if(BATTVOLT_STATE_ULTRALOW == *(uint32*)(l_msgInfo.parBufPtr))
					{
						l_event = PM_SIG_VOLT_ERROR;
					}
					else if(BATTVOLT_STATE_ULTRAHIGH == *(uint32*)(l_msgInfo.parBufPtr))
					{
						l_event = PM_SIG_VOLT_ERROR;
					}
					else
					{
						l_event = PM_SIG_VOLT_WARNING;
					}
					break;
					
				case SYSTEM_SIG_ID_UPDATE:
					if (1 == *(uint32*)(l_msgInfo.parBufPtr))
					{
						l_event = PM_SIG_SYS_UPDATE;
					}
					break;
				case SYSTEM_SIG_ID_60S:
					l_event = PM_SIG_60S;
					break;
				default:
					break;
			}
			
			if( l_event < PM_SIG_MAX )
				PM_Main(l_event);
			
		#endif

			/*===============================================================================*/
			/*================================ END: USER CODE ===============================*/
			/*===============================================================================*/
#if (STD_ON == TASK_POWERMODING_STACK_MONITOR)
			l_stackSize = uxTaskGetStackHighWaterMark(NULL);
#if (STD_ON == TASK_POWERMODING_DEBUG_TRACE)
			TracePrintf(PM_TRACE, TRACE_WARNING, "[Task_PowerModing-W]:Stack Size:%d\r\n",l_stackSize);
#endif
#endif
		}
	}
}
/*=========================== END OF FILE: Task_PowerModing.c ===========================*/
