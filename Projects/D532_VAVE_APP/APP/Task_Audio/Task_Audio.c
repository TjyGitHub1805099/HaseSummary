/*!Warning!:Please don't modify this file,this is generated by tools!*/
/********************************************************************
File name: Task_Audio.c
Author: Stephen Du
Version: V1.0
Timestamp: 2018-09-11 15:01:46
Description:
Others:
Function List:
1. ....
History: /
1. Date:
Author:
Modification:
2. ...
********************************************************************/
#include "System_Task.h"
#include "System_Signal.h"
#include "Task_Audio_Cfg.h"
#if (STD_ON == TASK_AUDIO_DEBUG_TRACE)
#include "trace.h"
#endif
/*********** START: INCLUDE FILES ************/
#include "dsp_global.h"
#include "dsp_driver_proj.h"
#include "dsp_driver.h"

#include "audio_control.h"
#include "amp_control_api.h"

/* ipc header */
#include "Spi_Ipc_gw_api.h"
#include "audio_ipc_config.h"

#include "audio_ipc_protocol.h"

#include "BoardDefines.h"
#include "HardwareVersion.h"
#include "Com_Cfg.h"
#include"CanApp.h"

/************ END: INCLUDE FILES *************/

void spiipc_notification_callback(uint16 function, uint8 *rx_data, uint32 len)
{
	
}

void spiipc_request_callback(const void *ctx, uint8 *rx_data, uint32 len)
{
	boolean ret;

	request_context_t *r_ctx = ctx;
	
	SystemTaskMsgInfoType l_message;

	/* check */

	/* send msg to audio task */
	/* TODO: command from android */
	l_message.msgId = SYSTEM_SIG_ID_AUDIO_SETTING;
	l_message.parBufPtr = rx_data;
	l_message.size = len;


	/* send msg */
	ret = System_Task_SendMessage(SYSTEM_TASK_ID_AUDIO, &l_message, false);
}

//tdf853x_instance amp_i2c;

void Task_Audio(void * pvParameters)
{
	boolean l_returnValue = E_NOT_OK;
	SystemTaskMsgInfoType l_msgInfo = {0XFFFF, 0U, NULL};
#if (STD_ON == TASK_AUDIO_STACK_MONITOR)
	uint16 l_stackSize = 0U;
#endif
	/*===============================================================================*/
	/*=============================== START: USER CODE ==============================*/
	/*===============================================================================*/
	/***************************** START: VARIABLE DEFINE ****************************/
	/*Warning: Change the following array size according to your real length.*/
	/* TODO: msg buffer size */
	uint8 l_msgDataBuf[100] = {0U};
	//tdf853x_instance amp_i2c;
	uint8 data[100] = {0U};

	int32_t ms100 = 0;
	uint32_t ecall_state = 0;

	// 532
	uint8 external_amp_mute_off = 1;
	// 532

	/****************************** END: VARIABLE DEFINE *****************************/
	
	/********************* START: SOMETHING ONLY NEED EXEC ONCE **********************/
	l_msgInfo.parBufPtr = &l_msgDataBuf[0];
	//audio_control_variable_init();

	/* ipc */
	/* TODO: ipc audio channel */
	ipc_gw_register(IPC_GW_CHANNEL_AUDIO, spiipc_notification_callback, spiipc_request_callback);

	/* check amp type */
	check_amp_type();

	if(amp_type == 1){
		dsp_project_ioctl(DSP_SET_AMP_TYPE, &amp_type);
	}else if(amp_type == 0){
		dsp_project_ioctl(DSP_SET_AMP_TYPE, &amp_type);
	}else{
		amp_type = 0;
		dsp_project_ioctl(DSP_SET_AMP_TYPE, &amp_type);
	}

	uint8_t circuit_version;
	circuit_version = (uint8_t)getCircuitVerion();

	dsp_project_ioctl(DSP_SET_HARDWARE_VERSION, &circuit_version);

	audio_car_model = getITMasterCtrlVerion();
	dsp_project_ioctl(DSP_SET_CAR_MODEL, &audio_car_model);

	dsp_spi_init();
	System_Task_Delay(50);
	amp_init();

	Com_SetSignal(SIG_HND_MUTE_ONOFF, &external_amp_mute_off);

	/* beep test */
#if 0
	tChimeCmd_ID testBeep;
	testBeep.action = CHIME_ACTION_START;
	testBeep.type = CHIME_TYPE_CONTINOUS;
	testBeep.id = 3;
	dsp_driver_ioctl(DSP_SET_CHIME_BY_ID, &testBeep);
#endif

#if 0
	tPDCCmd_ID testPdcBeep;
	testPdcBeep.action = PDC_ACTION_START;
	testPdcBeep.id = 0;
	dsp_driver_ioctl(DSP_SET_PDC_BY_ID, &testPdcBeep);
#endif
	/* click clack test */
#if 0
	tClickClarkCmd testClickClark;
	while(1){
		testClickClark.action = CLICK_ACTION;
		dsp_driver_ioctl(DSP_CLICKCLARK, &testClickClark);
		System_Task_Delay(200);
		testClickClark.action = CLACK_ACTION;
		dsp_driver_ioctl(DSP_CLICKCLARK, &testClickClark);
		System_Task_Delay(200);
	}
#endif

	/********************** END: SOMETHING ONLY NEED EXEC ONCE ***********************/



	/**************************** START: SIGNAL SUBSCRIBE ****************************/
	/*
	System_Signal_Subscribe(SYSTEM_SIG_ID_XXX, SYSTEM_TASK_ID_AUDIO);
	System_Signal_SubSpecValue(SYSTEM_SIG_ID_XXX, SYSTEM_TASK_ID_AUDIO, X);
	*/
	System_Signal_Subscribe(SYSTEM_SIG_ID_100MS, SYSTEM_TASK_ID_AUDIO);
	System_Signal_Subscribe(SYSTEM_SIG_ID_AUDIO_SETTING, SYSTEM_TASK_ID_AUDIO);
	System_Signal_Subscribe(SYSTEM_SIG_ID_AUDIO_BEEP, SYSTEM_TASK_ID_AUDIO);
	System_Signal_Subscribe(SYSTEM_SIG_ID_AUDIO_BEEP_PDC, SYSTEM_TASK_ID_AUDIO);
	System_Signal_Subscribe(SYSTEM_SIG_ID_AUDIO_CLICKCLACK, SYSTEM_TASK_ID_AUDIO);
	System_Signal_Subscribe(SYSTEM_SIG_ID_AUDIO_MUTE_BEEP, SYSTEM_TASK_ID_AUDIO);
	System_Signal_Subscribe(SYSTEM_SIG_ID_AUDIO_EXECUTE_LC_FILTER_DIAGNOSTICS, SYSTEM_TASK_ID_AUDIO);
	System_Signal_Subscribe(SYSTEM_SIG_ID_AUDIO_DO_ECALL, SYSTEM_TASK_ID_AUDIO);
	/***************************** END: SIGNAL SUBSCRIBE *****************************/
	/*===============================================================================*/
	/*================================ END: USER CODE ===============================*/
	/*===============================================================================*/
	while (1)
	{
		l_returnValue = System_Task_ReceiveMessage(SYSTEM_TASK_ID_AUDIO, &l_msgInfo, FALSE, OS_WAITFOREVER);
		if (E_OK == l_returnValue)
		{
			/*
			You can use: "l_msgInfo.msgId" to get the message id.
			You can use: "l_msgInfo.size" to get the message size.
			You can use: "l_msgInfo.parBufPtr[]" or "l_msgDataBuf[]"
			             to get the message content if the message size not equal 0.
			 */
			/*===============================================================================*/
			/*=============================== START: USER CODE ==============================*/
			/*===============================================================================*/
			/*if (SYSTEM_SIG_ID_XXX == l_msgInfo.msgId)
			{
#if (STD_ON == TASK_AUDIO_DEBUG_TRACE)
				TracePrintf(SYSTEM_TRACE, TRACE_INFO, "[Task_Audio-I]:Some infomation\r\n");
#endif
			}*/
			if(l_msgInfo.msgId == SYSTEM_SIG_ID_100MS){
				/* SSV 100ms calculate circle */
				/* TODO: SSV */
                uint8_t stat = DEA_GetRawVehicleSpeedErrorStat();
                if(stat == 0){
                    uint16_t speed = DEA_GetRawVehicleSpeed();
                    audio_handle_speed(speed / 10);
                }
                
				ms100++;
				if(ms100 == 2){
					dsp_project_ioctl(DSP_SET_AUDIO_BEAT_DISP, &ms100);
					ms100 = 0;
				}
			}

			if(l_msgInfo.msgId == SYSTEM_SIG_ID_AUDIO_SETTING){
#if 0
				/* TODO: copy msg */
				data = Mem_Malloc(l_msgInfo.size);
				if(data == NULL){
					TracePrintf(SYSTEM_TRACE, TRACE_WARNING, "audio task Mem_Malloc failed 1\r\n");
				}
#endif
#if 0
				TracePrintf(SYSTEM_TRACE, TRACE_WARNING, "audio message size:%d\r\n", l_msgInfo.size);
				TracePrintf(SYSTEM_TRACE, TRACE_WARNING, "audio message data: \r\n");
				int32_t *pt = l_msgInfo.parBufPtr;
				int i = 0;
				for(i = 0; i < l_msgInfo.size / 4; i++){
					TracePrintf(SYSTEM_TRACE, TRACE_WARNING, "%d\r\n", *pt);
					pt++;
				}
				TracePrintf(SYSTEM_TRACE, TRACE_WARNING, "audio message data: end\r\n");
#endif
				if(data != NULL){
					memcpy(data, l_msgInfo.parBufPtr, l_msgInfo.size);
					/* handle msg */
					audio_handle_ipc_msg(data, l_msgInfo.size);
					//Mem_Free(data);
					//data = NULL;
				}
			}

			if(l_msgInfo.msgId == SYSTEM_SIG_ID_AUDIO_BEEP){
#if 0
				/* TODO: copy msg */
				data = Mem_Malloc(l_msgInfo.size);
				if(data == NULL){
					TracePrintf(SYSTEM_TRACE, TRACE_WARNING, "audio task Mem_Malloc failed 1\r\n");
				}
#endif

				if(data != NULL){
					memcpy(data, l_msgInfo.parBufPtr, l_msgInfo.size);
					/* handle msg */
					dsp_driver_ioctl(DSP_SET_CHIME_BY_ID, data);
					//Mem_Free(data);
					//data = NULL;
				}
			}

			if(l_msgInfo.msgId == SYSTEM_SIG_ID_AUDIO_BEEP_PDC){
#if 0
				/* TODO: copy msg */
				data = Mem_Malloc(l_msgInfo.size);
				if(data == NULL){
					TracePrintf(SYSTEM_TRACE, TRACE_WARNING, "audio task Mem_Malloc failed 1\r\n");
				}
#endif

				if(data != NULL){
					memcpy(data, l_msgInfo.parBufPtr, l_msgInfo.size);
					/* handle msg */
					dsp_driver_ioctl(DSP_SET_PDC_BY_ID, data);
					//Mem_Free(data);
					//data = NULL;
				}
			}

			if(l_msgInfo.msgId == SYSTEM_SIG_ID_AUDIO_CLICKCLACK){
#if 0
				/* TODO: copy msg */
				data = Mem_Malloc(l_msgInfo.size);
				if(data == NULL){
					TracePrintf(SYSTEM_TRACE, TRACE_WARNING, "audio task Mem_Malloc failed 1\r\n");
				}
#endif

				if(data != NULL){
					memcpy(data, l_msgInfo.parBufPtr, l_msgInfo.size);
					/* handle msg */
					dsp_driver_ioctl(DSP_CLICKCLARK, data);
					//Mem_Free(data);
					//data = NULL;
				}
			}

			if(l_msgInfo.msgId == SYSTEM_SIG_ID_AUDIO_MUTE_BEEP){
#if 0
				/* TODO: copy msg */
				data = Mem_Malloc(l_msgInfo.size);
				if(data == NULL){
					TracePrintf(SYSTEM_TRACE, TRACE_WARNING, "audio task Mem_Malloc failed 1\r\n");
				}
#endif

				if(data != NULL){
					memcpy(data, l_msgInfo.parBufPtr, l_msgInfo.size);
					/* handle msg */
					dsp_driver_ioctl(DSP_SET_CHIME_MUTE, data);
					//Mem_Free(data);
					//data = NULL;
				}
			}

			if(l_msgInfo.msgId == SYSTEM_SIG_ID_AUDIO_EXECUTE_LC_FILTER_DIAGNOSTICS){
#if 0
				/* TODO: copy msg */
				data = Mem_Malloc(l_msgInfo.size);
				if(data == NULL){
					TracePrintf(SYSTEM_TRACE, TRACE_WARNING, "audio task Mem_Malloc failed 1\r\n");
				}
#endif

				if(data != NULL){
					data[AUDIOSPI_INDEX_TYPE] = AUDIOSPI_TYPE_REQ;
					data[AUDIOSPI_INDEX_FLAG] = 0;
					data[2] = 0;
					data[3] = 0;

					audio_ipc_setCmdId(AMP_LC_FILTER_DIAGNOSTICS_RETURN, &data[AUDIOSPI_HEADER_SIZE]);

					memcpy(&data[AUDIOSPI_HEADER_SIZE + 4], l_msgInfo.parBufPtr, l_msgInfo.size);
					/* handle msg */
					/* function parameter useless, set to 1 */
					ipc_send_notification(AUDIO_IPC_HW_CHANNEL, AUDIO_IPC_SW_CHANNEL, 1, data, l_msgInfo.size + AUDIOSPI_HEADER_SIZE + 4);
				}
			}

			if(l_msgInfo.msgId == SYSTEM_SIG_ID_AUDIO_DO_ECALL){
			#if 0
				/* TODO: copy msg */
				data = Mem_Malloc(l_msgInfo.size);
				if(data == NULL){
					TracePrintf(SYSTEM_TRACE, TRACE_WARNING, "audio task Mem_Malloc failed 1\r\n");
				}
			#endif

				if(data != NULL){
					uint8_t step;
					memcpy(data, l_msgInfo.parBufPtr, l_msgInfo.size);
					/* handle msg */
					if(data[0] == 1){
						if(ecall_state == 0){
							step = 1;
							dsp_driver_ioctl(DSP_ENTER_ECALL, &step);
							Port_SetOutLevel(MIC_TCU_SW, PORT_HIGH);
							System_Task_Delay(350);
							step = 2;
							dsp_driver_ioctl(DSP_ENTER_ECALL, &step);
							System_Signal_Send(SYSTEM_SIG_ID_ECALL_SPK_STATUS, 1, STD_OFF);
							ecall_state = 1;
						}
					}else{
						if(ecall_state == 1){
							step = 1;
							dsp_driver_ioctl(DSP_LEAVE_ECALL, &step);
							Port_SetOutLevel(MIC_TCU_SW, PORT_LOW);
							step = 2;
							dsp_driver_ioctl(DSP_LEAVE_ECALL, &step);
							ecall_state = 0;
						}
					}
				}
			}


			/*===============================================================================*/
			/*================================ END: USER CODE ===============================*/
			/*===============================================================================*/
#if (STD_ON == TASK_AUDIO_STACK_MONITOR)
			l_stackSize = uxTaskGetStackHighWaterMark(NULL);
#if (STD_ON == TASK_AUDIO_DEBUG_TRACE)
			TracePrintf(SYSTEM_TRACE, TRACE_WARNING, "[Task_Audio-W]:Stack Size:%d\r\n",l_stackSize);
#endif
#endif
		}
	}
}
/*=========================== END OF FILE: Task_Audio.c ===========================*/
